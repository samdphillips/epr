#lang rhombus/static/and_meta

import:
  lib("racket/base.rkt") as r
  lib("syncvar/main.rkt") as syncvar
  rhombus/compat/port
  rhombus/compat/thread:
    expose:
      thread
      Thread

def in_lines = r.#{in-lines}
def in_producer = r.#{in-producer}
def channel_put_evt = r.#{channel-put-evt}

interface OutputConnect:
  method send_ev(val)

  method send(val):
    r.sync(send_ev(val))

interface InputConnect:
  extends: Sequenceable
  method recv_ev()

  method recv():
    r.sync(recv_ev())

  override method to_sequence():
    in_producer(fun (): recv())

annot.macro 'Channel':
  annot_meta.pack_predicate('r.#{channel?}',
                            '(($(statinfo_meta.dot_provider_key),
                               channel_dot_provider))')

dot.macro 'channel_dot_provider $left . $right':
  match right
  | 'in_connect': 'fun (): ChannelInputConnect(~channel: $left)'
  | 'out_connect': 'fun (): ChannelOutputConnect(~channel: $left)'

fun make_channel() :~ Channel:
  r.#{make-channel}()

class ChannelInputConnect(~channel: ch :: Channel):
  implements: InputConnect

  override method recv_ev():
    ch

class ChannelOutputConnect(~channel: ch :: Channel):
  implements: OutputConnect

  override method send_ev(val):
    channel_put_evt(ch, val)

def IVar = syncvar.#{make-ivar}

namespace IVar:
  export Exn
  annot.macro 'Exn':
    annot_meta.pack_predicate('syncvar.#{exn:fail:ivar?}')

annot.macro 'IVar':
  annot_meta.pack_predicate('syncvar.#{ivar?}',
                            '(($(statinfo_meta.dot_provider_key),
                               ivar_dot_provider))')

dot.macro 'ivar_dot_provider $left . $right':
  match right
  | 'put':     'fun (val): syncvar.#{ivar-put!}($left, val)'
  | 'try_get': 'fun (): syncvar.#{ivar-try-get}($left)'

def MVar = syncvar.#{make-mvar}

namespace MVar:
  export update
  expr.macro 'update($mvar, $val):
                $body
                ...':
    'syncvar.#{mvar-update!}($mvar, fun ($val): $body ...)'

annot.macro 'MVar':
  annot_meta.pack_predicate('syncvar.#{mvar?}',
                            '(($(statinfo_meta.dot_provider_key),
                               mvar_dot_provider))')

dot.macro 'mvar_dot_provider $left . $right':
  match right
  | 'get': 'fun (): syncvar.#{mvar-get}($left)'
  | 'swap': 'fun (v): syncvar.#{mvar-swap!}($left, v)'

class Processor():
  nonfinal

  private field thd :: maybe(Thread) = #false
  private field stopping_evt :: maybe(IVar) = #false
  private field state :: MVar = MVar(#'stopped)
  field stopped_evt :: IVar = IVar()
  field dead_evt :: IVar = IVar()

  property current_state:
    state.get()

  private method state_transition(old, new):
    MVar.update(state, v):
      if v == old
      | new
      | error("processor cannot transition from " +& old +& " to " +& new)

  method start():
    state_transition(#'stopped, #'starting)
    stopping_evt := IVar()
    stopped_evt := IVar()
    thd := thread:
      try:
        on_start()
        state_transition(#'starting, #'running)
        process()
        state_transition(#'running, #'stopping)
        on_stop()
        state_transition(#'stopping, #'stopped)
        stopped_evt.put(#true)
        ~catch e :: Exn:
          state.swap(#'dead)
          on_dead()
          dead_evt.put(#true)

  method stop():
    match current_state
    | #'stopped || #'stopping || #'dead: #void
    | #'starting:
        r.sleep(0.5)
        stop()
    | #'running:
        try:
          (stopping_evt :~ IVar).put(#true)
          ~catch e :: IVar.Exn:
            #void

  method process():
    r.sync(r.#{handle-evt}(stopping_evt, r.void),
           r.#{handle-evt}(process_evt(), fun (v): on_event(v)))

  method on_start():
    #void

  method on_stop():
    #void

  method on_dead():
    #void

  abstract method process_evt()
  abstract method on_event(v)

#'here1

class PortSource(~input_port: inp :: port.InputPort = current_input_port(),
                 ~out: out :: OutputConnect):
  extends Processor

  override method process_evt():
   inp.readline_evt()

  method decorate(v):
    v

  override method on_event(v):
    when v is_a String
    | out.send(decorate(v))
      process()

#'here2
#//
class PortSink(~output_port: outp = current_output_port() :: port.OutputPort,
               ~in: in :: InputConnect):
  field thd = #false
  field stopping :: IVar = IVar()

  method start():
    thd := thread: process()

  method stop():
    stopping.put(#true)

  method process():
    for:
      each ev: in
      println(ev, outp)

#'here3


#//
module run:
  def ch = make_channel()
  // XXX supervise: check for dead processors
  def chout = ch.out_connect()
  //def src = PortSource(~out: ch.out_connect())
  //def snk = PortSink(~in: ch.in_connect())
  //src.start()
  //snk.start()
  //r.sync(r.#{never-evt})
